/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.2.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package com.ems.faultmns.api;

import com.ems.faultmns.model.AlarmAckState;
import com.ems.faultmns.model.AlarmCount;
import com.ems.faultmns.model.AlarmsAlarmIdPatchRequest;
import com.ems.faultmns.model.AlarmsGet200ResponseValue;
import com.ems.faultmns.model.AlarmsPatchRequest;
import com.ems.faultmns.model.Comment;
import com.ems.faultmns.model.ErrorResponse;
import com.ems.faultmns.model.FailedAlarm;
import java.util.Map;
import com.ems.faultmns.model.Subscription;
import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import jakarta.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen")
@Validated
@Tag(name = "Fault", description = "the Fault API")
public interface FaultApi {

    /**
     * GET /alarms/alarmCount : Get the alarm count per perceived severity
     *
     * @param alarmAckState  (optional)
     * @param filter  (optional)
     * @return Success case (\&quot;200 OK\&quot;). The alarm count per perceived severity is returned. (status code 200)
     *         or Response in case of error. The error case needs rework. (status code 200)
     */
    @Operation(
        operationId = "alarmsAlarmCountGet",
        summary = "Get the alarm count per perceived severity",
        tags = { "Fault" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Success case (\"200 OK\"). The alarm count per perceived severity is returned.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AlarmCount.class))
            }),
            @ApiResponse(responseCode = "default", description = "Response in case of error. The error case needs rework.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/alarms/alarmCount",
        produces = { "application/json" }
    )
    
    ResponseEntity<AlarmCount> alarmsAlarmCountGet(
        @Parameter(name = "alarmAckState", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "alarmAckState", required = false) AlarmAckState alarmAckState,
        @Parameter(name = "filter", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false) String filter
    );


    /**
     * POST /alarms/{alarmId}/comments : Add a comment to a single alarm
     * Adds a comment to an alarm identified by alarmId. The id of the new comment is allocated by the producer.
     *
     * @param alarmId Identifies the alarm to which the comment shall be added. (required)
     * @param comment  (required)
     * @return Success case (201 Created). The representation of the newly created comment resource shall be returned. (status code 201)
     *         or Error case. (status code 200)
     */
    @Operation(
        operationId = "alarmsAlarmIdCommentsPost",
        summary = "Add a comment to a single alarm",
        description = "Adds a comment to an alarm identified by alarmId. The id of the new comment is allocated by the producer.",
        tags = { "Fault" },
        responses = {
            @ApiResponse(responseCode = "201", description = "Success case (201 Created). The representation of the newly created comment resource shall be returned.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = Comment.class))
            }),
            @ApiResponse(responseCode = "default", description = "Error case.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/alarms/{alarmId}/comments",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    ResponseEntity<Comment> alarmsAlarmIdCommentsPost(
        @Parameter(name = "alarmId", description = "Identifies the alarm to which the comment shall be added.", required = true, in = ParameterIn.PATH) @PathVariable("alarmId") String alarmId,
        @Parameter(name = "Comment", description = "", required = true) @Valid @RequestBody Comment comment
    );


    /**
     * PATCH /alarms/{alarmId} : Clear, acknowledge or unacknowledge a single alarm
     * Clears, acknowledges or unacknowldeges a single alarm by patching the alarm information. A conditional acknowledge request based on the perceived severity is not supported.
     *
     * @param alarmId Identifies the alarm to be patched. (required)
     * @param alarmsAlarmIdPatchRequest  (required)
     * @return Success case (204 No content). The response message body is absent. (status code 204)
     *         or Response in case of error. (status code 200)
     */
    @Operation(
        operationId = "alarmsAlarmIdPatch",
        summary = "Clear, acknowledge or unacknowledge a single alarm",
        description = "Clears, acknowledges or unacknowldeges a single alarm by patching the alarm information. A conditional acknowledge request based on the perceived severity is not supported.",
        tags = { "Fault" },
        responses = {
            @ApiResponse(responseCode = "204", description = "Success case (204 No content). The response message body is absent."),
            @ApiResponse(responseCode = "default", description = "Response in case of error.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PATCH,
        value = "/alarms/{alarmId}",
        produces = { "application/json" },
        consumes = { "application/merge-patch+json" }
    )
    
    ResponseEntity<Void> alarmsAlarmIdPatch(
        @Parameter(name = "alarmId", description = "Identifies the alarm to be patched.", required = true, in = ParameterIn.PATH) @PathVariable("alarmId") String alarmId,
        @Parameter(name = "AlarmsAlarmIdPatchRequest", description = "", required = true) @Valid @RequestBody AlarmsAlarmIdPatchRequest alarmsAlarmIdPatchRequest
    );


    /**
     * GET /alarms : Retrieve multiple alarms
     * Retrieves the alarms identified by alarmAckState, baseObjectInstance and filter.
     *
     * @param alarmAckState  (optional)
     * @param baseObjectInstance  (optional)
     * @param filter  (optional)
     * @return Success case (\&quot;200 OK\&quot;). Returns the alarms identified in the request. The alarmId is the key of the map. (status code 200)
     *         or Response in case of error. (status code 200)
     */
    @Operation(
        operationId = "alarmsGet",
        summary = "Retrieve multiple alarms",
        description = "Retrieves the alarms identified by alarmAckState, baseObjectInstance and filter.",
        tags = { "Fault" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Success case (\"200 OK\"). Returns the alarms identified in the request. The alarmId is the key of the map.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AlarmsGet200ResponseValue.class))
            }),
            @ApiResponse(responseCode = "default", description = "Response in case of error.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/alarms",
        produces = { "application/json" }
    )
    
    ResponseEntity<Map<String, AlarmsGet200ResponseValue>> alarmsGet(
        @Parameter(name = "alarmAckState", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "alarmAckState", required = false) AlarmAckState alarmAckState,
        @Parameter(name = "baseObjectInstance", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "baseObjectInstance", required = false) String baseObjectInstance,
        @Parameter(name = "filter", description = "", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filter", required = false) String filter
    );


    /**
     * PATCH /alarms : Clear, acknowledge or unacknowledge multiple alarms
     * Clears, acknowledges or unacknowledges multiple alarms using patch. Depending on which action is to be performed, different merge patch documents need to be used.
     *
     * @param alarmsPatchRequest Patch documents for acknowledging and unacknowledging, or clearing multiple alarms. The keys in the map are the alarmIds to be patched. (optional)
     * @return Success case (\&quot;204 No content\&quot;). The response message body is empty. (status code 204)
     *         or Response in case of error. (status code 200)
     */
    @Operation(
        operationId = "alarmsPatch",
        summary = "Clear, acknowledge or unacknowledge multiple alarms",
        description = "Clears, acknowledges or unacknowledges multiple alarms using patch. Depending on which action is to be performed, different merge patch documents need to be used.",
        tags = { "Fault" },
        responses = {
            @ApiResponse(responseCode = "204", description = "Success case (\"204 No content\"). The response message body is empty."),
            @ApiResponse(responseCode = "default", description = "Response in case of error.", content = {
                @Content(mediaType = "application/json", array = @ArraySchema(schema = @Schema(implementation = FailedAlarm.class)))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PATCH,
        value = "/alarms",
        produces = { "application/json" },
        consumes = { "application/merge-patch+json" }
    )
    
    ResponseEntity<Void> alarmsPatch(
        @Parameter(name = "AlarmsPatchRequest", description = "Patch documents for acknowledging and unacknowledging, or clearing multiple alarms. The keys in the map are the alarmIds to be patched.") @Valid @RequestBody(required = false) AlarmsPatchRequest alarmsPatchRequest
    );


    /**
     * POST /subscriptions : Create a subscription
     * To create a subscription the representation of the subscription is POSTed on the /subscriptions collection resource.
     *
     * @param subscription  (required)
     * @return Success case (\&quot;201 Created\&quot;). The representation of the newly created subscription resource shall be returned. (status code 201)
     *         or Error case. (status code 200)
     */
    @Operation(
        operationId = "subscriptionsPost",
        summary = "Create a subscription",
        description = "To create a subscription the representation of the subscription is POSTed on the /subscriptions collection resource.",
        tags = { "Fault" },
        responses = {
            @ApiResponse(responseCode = "201", description = "Success case (\"201 Created\"). The representation of the newly created subscription resource shall be returned.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = Subscription.class))
            }),
            @ApiResponse(responseCode = "default", description = "Error case.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/subscriptions",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    ResponseEntity<Subscription> subscriptionsPost(
        @Parameter(name = "Subscription", description = "", required = true) @Valid @RequestBody Subscription subscription
    );


    /**
     * DELETE /subscriptions/{subscriptionId} : Delete a subscription
     * The subscription is deleted by deleting the corresponding subscription resource. The resource to be deleted is identified with the path component of the URI.
     *
     * @param subscriptionId Identifies the subscription to be deleted. (required)
     * @return Success case (\&quot;204 No Content\&quot;). The subscription resource has been deleted. The response message body is absent. (status code 204)
     *         or Error case. (status code 200)
     */
    @Operation(
        operationId = "subscriptionsSubscriptionIdDelete",
        summary = "Delete a subscription",
        description = "The subscription is deleted by deleting the corresponding subscription resource. The resource to be deleted is identified with the path component of the URI.",
        tags = { "Fault" },
        responses = {
            @ApiResponse(responseCode = "204", description = "Success case (\"204 No Content\"). The subscription resource has been deleted. The response message body is absent."),
            @ApiResponse(responseCode = "default", description = "Error case.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/subscriptions/{subscriptionId}",
        produces = { "application/json" }
    )
    
    ResponseEntity<Void> subscriptionsSubscriptionIdDelete(
        @Parameter(name = "subscriptionId", description = "Identifies the subscription to be deleted.", required = true, in = ParameterIn.PATH) @PathVariable("subscriptionId") String subscriptionId
    );

}
